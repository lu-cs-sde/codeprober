// Automatically generated by protocolgen.GenJava. DO NOT MODIFY
package codeprober.protocol.data;

import org.json.JSONObject;

@SuppressWarnings("unchecked")
public class AsyncRpcUpdateValue implements codeprober.util.JsonUtil.ToJsonable {
  public static enum Type {
    status,
    workerStackTrace,
    workerStatuses,
    workerTaskDone,
  }
  private static final Type[] typeValues = Type.values();

  public final Type type;
  public final Object value;
  private AsyncRpcUpdateValue(Type type, Object value) {
    this.type = type;
    this.value = value;
  }
  public AsyncRpcUpdateValue(java.io.DataInputStream src) throws java.io.IOException {
    this(new codeprober.protocol.BinaryInputStream.DataInputStreamWrapper(src));
  }
  public AsyncRpcUpdateValue(codeprober.protocol.BinaryInputStream src) throws java.io.IOException {
    this.type = typeValues[src.readInt()];
    switch (this.type) {
    case status:
        this.value = src.readUTF();
        break;
    case workerStackTrace:
        this.value = codeprober.util.JsonUtil.<String>readDataArr(src, () -> src.readUTF());
        break;
    case workerStatuses:
        this.value = codeprober.util.JsonUtil.<String>readDataArr(src, () -> src.readUTF());
        break;
    case workerTaskDone:
    default:
        this.value = new WorkerTaskDone(src);
        break;
    }
  }
  public static AsyncRpcUpdateValue fromStatus(String val) { return new AsyncRpcUpdateValue(Type.status, val); }
  public static AsyncRpcUpdateValue fromWorkerStackTrace(java.util.List<String> val) { return new AsyncRpcUpdateValue(Type.workerStackTrace, val); }
  public static AsyncRpcUpdateValue fromWorkerStatuses(java.util.List<String> val) { return new AsyncRpcUpdateValue(Type.workerStatuses, val); }
  public static AsyncRpcUpdateValue fromWorkerTaskDone(WorkerTaskDone val) { return new AsyncRpcUpdateValue(Type.workerTaskDone, val); }

  public boolean isStatus() { return type == Type.status; }
  public String asStatus() { if (type != Type.status) { throw new IllegalStateException("This AsyncRpcUpdateValue is not of type status, it is '" + type + "'"); } return (String)value; }
  public boolean isWorkerStackTrace() { return type == Type.workerStackTrace; }
  public java.util.List<String> asWorkerStackTrace() { if (type != Type.workerStackTrace) { throw new IllegalStateException("This AsyncRpcUpdateValue is not of type workerStackTrace, it is '" + type + "'"); } return (java.util.List<String>)value; }
  public boolean isWorkerStatuses() { return type == Type.workerStatuses; }
  public java.util.List<String> asWorkerStatuses() { if (type != Type.workerStatuses) { throw new IllegalStateException("This AsyncRpcUpdateValue is not of type workerStatuses, it is '" + type + "'"); } return (java.util.List<String>)value; }
  public boolean isWorkerTaskDone() { return type == Type.workerTaskDone; }
  public WorkerTaskDone asWorkerTaskDone() { if (type != Type.workerTaskDone) { throw new IllegalStateException("This AsyncRpcUpdateValue is not of type workerTaskDone, it is '" + type + "'"); } return (WorkerTaskDone)value; }

  public static AsyncRpcUpdateValue fromJSON(JSONObject obj) {
    final Type type;
    try { type = Type.valueOf(obj.getString("type")); }
    catch (IllegalArgumentException e) { throw new org.json.JSONException(e); }
    switch (type) {
    case status:
      try {
        final String val = obj.getString("value");
        return fromStatus(val);
      } catch (org.json.JSONException e) {
        throw new org.json.JSONException("Not a valid AsyncRpcUpdateValue", e);
      }
    case workerStackTrace:
      try {
        final java.util.List<String> val = codeprober.util.JsonUtil.<String>mapArr(obj.getJSONArray("value"), (arr, idx) -> arr.getString(idx));
        return fromWorkerStackTrace(val);
      } catch (org.json.JSONException e) {
        throw new org.json.JSONException("Not a valid AsyncRpcUpdateValue", e);
      }
    case workerStatuses:
      try {
        final java.util.List<String> val = codeprober.util.JsonUtil.<String>mapArr(obj.getJSONArray("value"), (arr, idx) -> arr.getString(idx));
        return fromWorkerStatuses(val);
      } catch (org.json.JSONException e) {
        throw new org.json.JSONException("Not a valid AsyncRpcUpdateValue", e);
      }
    case workerTaskDone:
    default:
      try {
        final WorkerTaskDone val = WorkerTaskDone.fromJSON(obj.getJSONObject("value"));
        return fromWorkerTaskDone(val);
      } catch (org.json.JSONException e) {
        throw new org.json.JSONException("Not a valid AsyncRpcUpdateValue", e);
      }
    }
  }

  public JSONObject toJSON() {
    final JSONObject ret = new JSONObject().put("type", type.name());
    switch (type) {
    case status:
      ret.put("value", ((String)value));
      break;
    case workerStackTrace:
      ret.put("value", new org.json.JSONArray(((java.util.List<String>)value)));
      break;
    case workerStatuses:
      ret.put("value", new org.json.JSONArray(((java.util.List<String>)value)));
      break;
    case workerTaskDone:
    default:
      ret.put("value", ((WorkerTaskDone)value).toJSON());
      break;
    }
    return ret;
  }
  public void writeTo(java.io.DataOutputStream dst) throws java.io.IOException {
    writeTo(new codeprober.protocol.BinaryOutputStream.DataOutputStreamWrapper(dst));
  }
  public void writeTo(codeprober.protocol.BinaryOutputStream dst) throws java.io.IOException {
    dst.writeInt(type.ordinal());
    switch (type) {
    case status:
      dst.writeUTF(((String)value));
      break;
    case workerStackTrace:
      codeprober.util.JsonUtil.<String>writeDataArr(dst, ((java.util.List<String>)value), ent -> dst.writeUTF(ent));
      break;
    case workerStatuses:
      codeprober.util.JsonUtil.<String>writeDataArr(dst, ((java.util.List<String>)value), ent -> dst.writeUTF(ent));
      break;
    case workerTaskDone:
    default:
      ((WorkerTaskDone)value).writeTo(dst);
      break;
    }
  }
}
