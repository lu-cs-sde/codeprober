// Automatically generated by protocolgen.GenJava. DO NOT MODIFY
package codeprober.protocol.data;

import org.json.JSONObject;

public class PropertyArg implements codeprober.util.JsonUtil.ToJsonable {
  public static enum Type {
    string,
    integer,
    bool,
    collection,
    outputstream,
    nodeLocator,
  }
  private static final Type[] typeValues = Type.values();

  public final Type type;
  public final Object value;
  private PropertyArg(Type type, Object value) {
    this.type = type;
    this.value = value;
  }
  public PropertyArg(java.io.DataInputStream src) throws java.io.IOException {
    this(new codeprober.protocol.BinaryInputStream.DataInputStreamWrapper(src));
  }
  public PropertyArg(codeprober.protocol.BinaryInputStream src) throws java.io.IOException {
    this.type = typeValues[src.readInt()];
    switch (this.type) {
    case string:
        this.value = src.readUTF();
        break;
    case integer:
        this.value = src.readInt();
        break;
    case bool:
        this.value = src.readBoolean();
        break;
    case collection:
        this.value = new PropertyArgCollection(src);
        break;
    case outputstream:
        this.value = src.readUTF();
        break;
    case nodeLocator:
    default:
        this.value = new NullableNodeLocator(src);
        break;
    }
  }
  public static PropertyArg fromString(String val) { return new PropertyArg(Type.string, val); }
  public static PropertyArg fromInteger(int val) { return new PropertyArg(Type.integer, val); }
  public static PropertyArg fromBool(boolean val) { return new PropertyArg(Type.bool, val); }
  public static PropertyArg fromCollection(PropertyArgCollection val) { return new PropertyArg(Type.collection, val); }
  public static PropertyArg fromOutputstream(String val) { return new PropertyArg(Type.outputstream, val); }
  public static PropertyArg fromNodeLocator(NullableNodeLocator val) { return new PropertyArg(Type.nodeLocator, val); }

  public boolean isString() { return type == Type.string; }
  public String asString() { if (type != Type.string) { throw new IllegalStateException("This PropertyArg is not of type string, it is '" + type + "'"); } return (String)value; }
  public boolean isInteger() { return type == Type.integer; }
  public int asInteger() { if (type != Type.integer) { throw new IllegalStateException("This PropertyArg is not of type integer, it is '" + type + "'"); } return (int)value; }
  public boolean isBool() { return type == Type.bool; }
  public boolean asBool() { if (type != Type.bool) { throw new IllegalStateException("This PropertyArg is not of type bool, it is '" + type + "'"); } return (boolean)value; }
  public boolean isCollection() { return type == Type.collection; }
  public PropertyArgCollection asCollection() { if (type != Type.collection) { throw new IllegalStateException("This PropertyArg is not of type collection, it is '" + type + "'"); } return (PropertyArgCollection)value; }
  public boolean isOutputstream() { return type == Type.outputstream; }
  public String asOutputstream() { if (type != Type.outputstream) { throw new IllegalStateException("This PropertyArg is not of type outputstream, it is '" + type + "'"); } return (String)value; }
  public boolean isNodeLocator() { return type == Type.nodeLocator; }
  public NullableNodeLocator asNodeLocator() { if (type != Type.nodeLocator) { throw new IllegalStateException("This PropertyArg is not of type nodeLocator, it is '" + type + "'"); } return (NullableNodeLocator)value; }

  public static PropertyArg fromJSON(JSONObject obj) {
    final Type type;
    try { type = Type.valueOf(obj.getString("type")); }
    catch (IllegalArgumentException e) { throw new org.json.JSONException(e); }
    switch (type) {
    case string:
      try {
        final String val = obj.getString("value");
        return fromString(val);
      } catch (org.json.JSONException e) {
        throw new org.json.JSONException("Not a valid PropertyArg", e);
      }
    case integer:
      try {
        final int val = obj.getInt("value");
        return fromInteger(val);
      } catch (org.json.JSONException e) {
        throw new org.json.JSONException("Not a valid PropertyArg", e);
      }
    case bool:
      try {
        final boolean val = obj.getBoolean("value");
        return fromBool(val);
      } catch (org.json.JSONException e) {
        throw new org.json.JSONException("Not a valid PropertyArg", e);
      }
    case collection:
      try {
        final PropertyArgCollection val = PropertyArgCollection.fromJSON(obj.getJSONObject("value"));
        return fromCollection(val);
      } catch (org.json.JSONException e) {
        throw new org.json.JSONException("Not a valid PropertyArg", e);
      }
    case outputstream:
      try {
        final String val = obj.getString("value");
        return fromOutputstream(val);
      } catch (org.json.JSONException e) {
        throw new org.json.JSONException("Not a valid PropertyArg", e);
      }
    case nodeLocator:
    default:
      try {
        final NullableNodeLocator val = NullableNodeLocator.fromJSON(obj.getJSONObject("value"));
        return fromNodeLocator(val);
      } catch (org.json.JSONException e) {
        throw new org.json.JSONException("Not a valid PropertyArg", e);
      }
    }
  }

  public JSONObject toJSON() {
    final JSONObject ret = new JSONObject().put("type", type.name());
    switch (type) {
    case string:
      ret.put("value", ((String)value));
      break;
    case integer:
      ret.put("value", ((int)value));
      break;
    case bool:
      ret.put("value", ((boolean)value));
      break;
    case collection:
      ret.put("value", ((PropertyArgCollection)value).toJSON());
      break;
    case outputstream:
      ret.put("value", ((String)value));
      break;
    case nodeLocator:
    default:
      ret.put("value", ((NullableNodeLocator)value).toJSON());
      break;
    }
    return ret;
  }
  public void writeTo(java.io.DataOutputStream dst) throws java.io.IOException {
    writeTo(new codeprober.protocol.BinaryOutputStream.DataOutputStreamWrapper(dst));
  }
  public void writeTo(codeprober.protocol.BinaryOutputStream dst) throws java.io.IOException {
    dst.writeInt(type.ordinal());
    switch (type) {
    case string:
      dst.writeUTF(((String)value));
      break;
    case integer:
      dst.writeInt(((int)value));
      break;
    case bool:
      dst.writeBoolean(((boolean)value));
      break;
    case collection:
      ((PropertyArgCollection)value).writeTo(dst);
      break;
    case outputstream:
      dst.writeUTF(((String)value));
      break;
    case nodeLocator:
    default:
      ((NullableNodeLocator)value).writeTo(dst);
      break;
    }
  }
}
